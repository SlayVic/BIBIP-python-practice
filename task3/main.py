import PyQt5 as qt  # * inport PyQt5 just in case
from PyQt5.QtWidgets import (  # * import all necessary
    QApplication,
    QMainWindow,
    QMessageBox,
    QShortcut,
    QTableWidgetItem,
)
from c19_ui import Ui_MainWindow  # * import ui generated by pyuic
from c19_api import C19_info  # * import my library to work with API
import sys  # * just to close program


class Main(QMainWindow):  # * class of application window
    def __init__(self):
        super(Main, self).__init__()  # * inherit
        self.ui = Ui_MainWindow()  # * use ui from c19_ui.py
        self.ui.setupUi(self)
        self.c19_info = C19_info()  # * c19 library variable
        self.current_country = ""  # * variable to reload
        self.fill_table()  # * fill table with EU countries

        # * setup refresh events
        self.ui.refresh.clicked.connect(self.__refresh)  # * on refresh botton click
        QShortcut("ctrl+r", self).activated.connect(self.__refresh)  # * on "ctrl+r"

        # * setup search events
        self.ui.search.clicked.connect(self.__search)  # * on search botton click
        self.ui.search_input.returnPressed.connect(
            self.__search
        )  # * on return key press

        # * focus search line on "ctrl + s"
        QShortcut("ctrl+s", self).activated.connect(
            lambda: self.ui.search_input.setFocus()
        )

    def fill_table(self, country=""):
        """
        Fill table with statistics from country of the world.

        Args:
            country (str, optional): get country name, full, 2 or 3 letters varian.
            If void make fill with EU countries
        """

        # * try update statistic with given country
        try:
            # * if error will  occur, it heppend here
            self.c19_info.update_data_with(country)

            data = self.c19_info.get_table_columns()  # * if not get data
            self.current_country = country  # * and set current country in case refresh
        except:  # * if error occur
            self.__search_error()  # * out search error
            return  # * exit function

        # * make table 0 size to clear it
        self.ui.tableWidget.setRowCount(0)
        self.ui.tableWidget.setColumnCount(0)

        table_Headers = []

        # * make table row and column to needed count
        self.ui.tableWidget.setColumnCount(len(data))
        self.ui.tableWidget.setRowCount(len(list(data.values())[0]))

        # * fill table
        for n, key in enumerate(data.keys()):
            table_Headers.append(key)
            for m, item in enumerate(data[key]):
                newitem = QTableWidgetItem(item)
                self.ui.tableWidget.setItem(m, n, newitem)
        # * rename columns to table_Headers
        self.ui.tableWidget.setHorizontalHeaderLabels(table_Headers)

        # * resize row and column to content
        self.ui.tableWidget.resizeColumnsToContents()
        self.ui.tableWidget.resizeRowsToContents()

    def __refresh(self):
        """Refresh table content"""
        self.fill_table(self.current_country)

    def __search(self):
        """Set table content to content from search field"""
        self.fill_table(self.ui.search_input.text())

    def __search_error(self):
        """Out search error if not found anything"""
        dlg = QMessageBox(self)
        dlg.setWindowTitle("ALARM!")
        dlg.setText(
            "Cant find anything with this search input, try use 2/3 letters country name instead of full.\nBlank search mean all european countries"
        )
        button = dlg.exec()


if __name__ == "__main__":
    app = QApplication([])
    application = Main()
    application.show()

    sys.exit(app.exec())
